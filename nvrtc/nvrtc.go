package nvrtc



//#include <nvrtc.h>
import "C"
import (
	"unsafe"
	"runtime"
)
//Version returns the version major and minor
func Version() (major, minor int, err error) {
	var maj, min C.int
	err = status(C.nvrtcVersion(&maj, &min)).error("Version")
	return int(maj), int(min), err
}
//Program is a wrapper for C.nvrtcProgram
type Program struct {
	c C.nvrtcProgram
	src *C.char
	name *C.char
	numofheaders C.int
	headers []*C.char
	names []*C.char
	numofoptions C.int
	options []*C.char


}
//Include are the headers for include
type Include struct {
	Source string
	Name   string
}
//CreateProgram creates an instance of nvrtcProgram with the given input parameters, and sets the output parameter prog with it.
func CreateProgram(src, name string, headers ...Include) (p *Program, err error) {
	p=new(Program)
	p.src = C.CString(src)
	p.name = C.CString(name)
	if len(headers) == 0 {
		runtime.SetFinalizer(p, nvrtcDestroyProgram)
		err = status(C.nvrtcCreateProgram(&p.c, p.src, p.name, 0, nil, nil)).error("CreateProgram")
		return p, err
	}

	p.numofheaders = (C.int)(len(headers))
	p.headers = make([]*C.char, p.numofheaders)
	p.names = make([]*C.char, p.numofheaders)
	for i, header := range headers {
		p.headers[i] = C.CString(header.Source)
		p.names[i] = C.CString(header.Name)
	}
	err = status(C.nvrtcCreateProgram(&p.c, p.src, p.name,p.numofheaders, &p.headers[0], &p.names[0])).error("CreateProgram")
	runtime.SetFinalizer(p, nvrtcDestroyProgram)
	return p, err
}
func nvrtcDestroyProgram(p * Program)error{
	return p.destroy()
}
func (p *Program) destroy() error {
	for i:=range p.names{
		C.free(unsafe.Pointer(p.names[i]))
		C.free(unsafe.Pointer(p.headers[i]))
	}
	for i := range p.options {
		C.free(unsafe.Pointer(p.options[i]))
	}
	C.free(unsafe.Pointer(p.src))
	C.free(unsafe.Pointer(p.name))
	err := status(C.nvrtcDestroyProgram(&p.c)).error("Destroy")
	*p = Program{}
	return err
}
//Compile compiles the given program.
func (p *Program) Compile(options ...string) error {
	if len(options) == 0 {
		if len(p.options)==0{
			return status(C.nvrtcCompileProgram(p.c, 0, nil)).error("Compile")
		}
		for i := range p.options {
			C.free(unsafe.Pointer(p.options[i]))
		}
		p.options=nil
		return status(C.nvrtcCompileProgram(p.c, 0, nil)).error("Compile")
	}
	if len(p.options)>0{
		for i := range p.options {
			C.free(unsafe.Pointer(p.options[i]))
		}
		p.options=nil
	}
	p.numofoptions= (C.int)(len(options))
	p.options = make([]*C.char, 	p.numofoptions)
	for i := range options { 
		p.options[i] = C.CString(options[i])
	}

	return status(C.nvrtcCompileProgram(p.c, p.numofoptions, &p.options[0])).error("Compile")
}
//PTX returns a string of the ptx code for the program
func (p *Program) PTX() (string, error) {
	var size C.size_t
	err  :=status(C.nvrtcGetPTXSize(p.c, &size)).error("GetPTX : nvrtcGetPTXSize ")
	if err != nil {
		return "", err
	}
	data := make([]byte, size+1)
	err = status(C.nvrtcGetPTX(p.c, (*C.char)(unsafe.Pointer(&data[0])))).error("GetPTX")
	if err != nil {
		return "", err
	}
	return string(data[:size]), err
}
//GetLog returns the log generated by the previous compilation
func (p *Program) GetLog() (string, error) {
	var size C.size_t
	err := status(C.nvrtcGetProgramLogSize(p.c, &size)).error("GetLog")
	if err != nil {
		return "", err
	}
	data := make([]byte, size+1)
	err = status(C.nvrtcGetProgramLog(p.c, (*C.char)(unsafe.Pointer(&data[0])))).error("GetLog")
	return (string)(data[:size]), err
}
//AddNameExpression notes the given name expression denoting the address of a __global__ function or __device__/__constant__ variable.
//
//The identical name expression string must be provided on a subsequent call to nvrtcGetLoweredName to extract the lowered name.
func (p *Program) AddNameExpression(nameExpression string) error {
	cstr := C.CString(nameExpression)
	defer C.free(unsafe.Pointer(cstr))
	return status(C.nvrtcAddNameExpression(p.c, cstr)).error("AddNameExpression")
}
//GetLoweredName extracts the lowered (mangled) name for a __global__ function or __device__/__constant__ variable, 
//and updates *lowered_name to point to it. The memory containing the name is released when the NVRTC program is destroyed 
//by nvrtcDestroyProgram. The identical name expression must have been previously provided to nvrtcAddNameExpression.
func (p *Program) GetLoweredName(nameExpression string) (string, error) {
	cstr := C.CString(nameExpression)
	defer C.free(unsafe.Pointer(cstr))

	var loweredName *C.char
	err := status(C.nvrtcGetLoweredName(p.c, cstr, &loweredName)).error("GetLoweredName")
	if err != nil {
		return "", err
	}
	return C.GoString(loweredName), nil
}