package npp

/*
#include <nppi_geometry_transforms.h>
#include <nppdefs.h>
*/
import "C"
import (
	"unsafe"
)

/** @defgroup image_geometry_transforms Geometry Transforms
 *  @ingroup nppi
 *
 * Routines manipulating an image geometry.
 *
 * These functions can be found in the nppig library. Linking to only the sub-libraries that you use can significantly
 * save link time, application load time, and CUDA runtime startup time when using dynamic libraries.
 *
 * \section geometric_transform_api Geometric Transform API Specifics
 *
 * This section covers some of the unique API features common to the
 * geometric transform primitives.
 *
 * \subsection geometric_transform_roi Geometric Transforms and ROIs
 *
 * Geometric transforms operate on source and destination ROIs. The way
 * these ROIs affect the processing of pixels differs from other (non
 * geometric) image-processing primitives: Only pixels in the intersection
 * of the destination ROI and the transformed source ROI are being
 * processed.
 *
 * The typical processing proceedes as follows:
 * -# Transform the rectangular source ROI (given in source image coordinates)
 *		into the destination image space. This yields a quadrilateral.
 * -# Write only pixels in the intersection of the transformed source ROI and
 *		the destination ROI.
 *
 * \subsection geometric_transforms_interpolation Pixel Interpolation
 *
 * The majority of image geometry transform operation need to perform a
 * resampling of the source image as source and destination pixels are not
 * coincident.
 *
 * NPP supports the following pixel inerpolation modes (in order from fastest to
 * slowest and lowest to highest quality):
 * - nearest neighbor
 * - linear interpolation
 * - cubic convolution
 * - supersampling
 * - interpolation using Lanczos window function
 *
 * @{
 *
 */

/** @defgroup image_resize_square_pixel ResizeSqrPixel
 *
 * ResizeSqrPixel supports the following interpolation modes:
 *
 * \code
 *   NPPI_INTER_NN
 *   NPPI_INTER_LINEAR
 *   NPPI_INTER_CUBIC
 *   NPPI_INTER_CUBIC2P_BSPLINE
 *   NPPI_INTER_CUBIC2P_CATMULLROM
 *   NPPI_INTER_CUBIC2P_B05C03
 *   NPPI_INTER_SUPER
 *   NPPI_INTER_LANCZOS
 * \endcode
 *
 * ResizeSqrPixel attempts to choose source pixels that would approximately represent the center of the destination pixels.
 * It does so by using the following scaling formula to select source pixels for interpolation:
 *
 * \code
 *   nAdjustedXFactor = 1.0 / nXFactor;
 *   nAdjustedYFactor = 1.0 / nYFactor;
 *   nAdjustedXShift = nXShift * nAdjustedXFactor + ((1.0 - nAdjustedXFactor) * 0.5);
 *   nAdjustedYShift = nYShift * nAdjustedYFactor + ((1.0 - nAdjustedYFactor) * 0.5);
 *   nSrcX = nAdjustedXFactor * nDstX - nAdjustedXShift;
 *   nSrcY = nAdjustedYFactor * nDstY - nAdjustedYShift;
 * \endcode
 *
 * In the ResizeSqrPixel functions below source image clip checking is handled as follows:
 *
 * If the source pixel fractional x and y coordinates are greater than or equal to oSizeROI.x and less than oSizeROI.x + oSizeROI.width and
 * greater than or equal to oSizeROI.y and less than oSizeROI.y + oSizeROI.height then the source pixel is considered to be within
 * the source image clip rectangle and the source image is sampled.  Otherwise the source image is not sampled and a destination pixel is not
 * written to the destination image.
 *
 * \section resize_error_codes Error Codes
 * The resize primitives return the following error codes:
 *
 *         - ::NPP_WRONG_INTERSECTION_ROI_ERROR indicates an error condition if
 *           srcROIRect has no intersection with the source image.
 *         - ::NPP_RESIZE_NO_OPERATION_ERROR if either destination ROI width or
 *           height is less than 1 pixel.
 *         - ::NPP_RESIZE_FACTOR_ERROR Indicates an error condition if either nXFactor or
 *           nYFactor is less than or equal to zero or in the case of NPPI_INTER_SUPER are not both downscaling.
 *         - ::NPP_INTERPOLATION_ERROR if eInterpolation has an illegal value.
 *         - ::NPP_SIZE_ERROR if source size width or height is less than 2 pixels.
 *
 * @{
 *
 */

/** @name GetResizeRect
 * Returns NppiRect which represents the offset and size of the destination rectangle that would be generated by
 * resizing the source NppiRect by the requested scale factors and shifts.
 *
 * @{
 *
 */

//Quad is set size array used in some geometry transformations
//Make one like x:=npp.Quad{{1,2},(3,4},(5,6},(7,8}}
type Quad [4][2]C.double

func (q *Quad) cptr2() *[2]C.double {
	return (*[2]C.double)(&q[0])
}

//Bound is set size array for geometry transformations
//Make one like x:=npp.Bound{{1,2},(3,4}}
type Bound [2][2]C.double

func (b *Bound) cptr2() *[2]C.double {
	return (*[2]C.double)((&b[0]))
}

//Coeffs is set size array for geometry transformations
//Make one like x:=npp.Coeffs{{1,2},(3,4},{5,6}}
type Coeffs [2][3]C.double

func (c *Coeffs) cptr2() *[3]C.double {
	return (*[3]C.double)(&c[0])
}
func (c *Coeffs) cptr() *C.double {
	return (*C.double)(&c[0][0])
}

//PerspectiveCoeffs is a different size coeffs than the normal one.  Instead of 2 rows it has 3
type PerspectiveCoeffs [3][3]C.double

func (c *PerspectiveCoeffs) cptr() *C.double {
	return (*C.double)(&c[0][0])
}
func (c *PerspectiveCoeffs) cptr2() *[3]C.double {
	return (*[3]C.double)(&c[0])
}

//GetResizeRect are functions found in the nppi library for cuda
func GetResizeRect(oSrcROI Rect, nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode) (Rect, error) {
	var dest C.NppiRect

	err := status(C.nppiGetResizeRect(
		(C.NppiRect)((oSrcROI)),
		&dest,
		(C.double)(nXFactor),
		(C.double)(nYFactor),
		(C.double)(nXShift),
		(C.double)(nYShift),
		eInterpolation.cint())).ToError()

	return (Rect)(dest), err
}

//ResizeSqrPixel8uC1R are functions found in the nppi library for cuda
// if ctx is nil function will do regular operation
func ResizeSqrPixel8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeSqrPixel_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel8uAC4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel8uP3R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel8uP4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel16uC1R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel16uC3R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16uC4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16uAC4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16uP3R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel16uP4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel16sC1R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16sC1R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel16sC3R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16sC3R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16sC4R are functions found in the nppi library for cuda if ctx is nil function will do regular operation if not nill  it will do Ctx version
func ResizeSqrPixel16sC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel16sAC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel16sP3R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 3)
	destcptrs := make([]*C.Npp16s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel16sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel16sP4R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int16, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 4)
	destcptrs := make([]*C.Npp16s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_16s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_16s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeSqrPixel32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 3)
	destcptrs := make([]*C.Npp32f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 4)
	destcptrs := make([]*C.Npp32f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fC1R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fC3R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fAC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fP3R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 3)
	destcptrs := make([]*C.Npp64f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeSqrPixel64fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel64fP4R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float64, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 4)
	destcptrs := make([]*C.Npp64f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_64f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_64f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), (C.double)(nXShift), (C.double)(nYShift), eInterpolation.cint(), ctx.c())).ToError()

}

//ResizeAdvancedGetBufferHostSize8uC1R are functions found in the nppi library for cuda.
func ResizeAdvancedGetBufferHostSize8uC1R(oSrcROI, oDstROI Size, eInterpolationMode InterpolationMode) (buffersize int32, err error) {
	var bufsize C.int
	err = status(C.nppiResizeAdvancedGetBufferHostSize_8u_C1R(oSrcROI.c(), oDstROI.c(), &bufsize, eInterpolationMode.cint())).ToError()
	buffersize = (int32)(bufsize)
	return buffersize, err

}

//ResizeSqrPixel8uC1RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeSqrPixel8uC1RAdvanced(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, nDstStep int32, oDstROI Rect,
	nXFactor, nYFactor float64,
	pBuff *Uint8, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResizeSqrPixel_8u_C1R_Advanced(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), pBuff.cptr(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResizeSqrPixel_8u_C1R_Advanced_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nXFactor), (C.double)(nYFactor), pBuff.cptr(), eInterpolation.cint(), ctx.c())).ToError()

}

//GetResizeTiledSourceOffset are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetResizeTiledSourceOffset(oSrcRectROI, oDstRectROI Rect) (SrcRectOffset Point, err error) {
	var pnt C.NppiPoint
	err = status(C.nppiGetResizeTiledSourceOffset(oSrcRectROI.c(), oDstRectROI.c(), &pnt)).ToError()
	SrcRectOffset = (Point)(pnt)
	return SrcRectOffset, err
}

//Resize8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_8u_C1R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_8u_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Resize8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_8u_C3R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_8u_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_8u_C4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_8u_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint8, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_8u_AC4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_8u_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_8u_P3R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_8u_P3R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_8u_P4R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_8u_P4R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16u_C1R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()

	}
	return status(C.nppiResize_16u_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16u_C3R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16u_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16u_C4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16u_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Uint16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16u_AC4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16u_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_16u_P3R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16u_P3R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_16u_P4R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16u_P4R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sC1R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16s_C1R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sC3R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16s_C3R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16s_C4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sAC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Int16, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_16s_AC4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sP3R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int16, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 3)
	destcptrs := make([]*C.Npp16s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_16s_P3R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_P3R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize16sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize16sP4R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int16, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 4)
	destcptrs := make([]*C.Npp16s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_16s_P4R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_16s_P4R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_32f_C1R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_32f_C3R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_32f_C4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst *Float32, oDestSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiResize_32f_AC4R(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDestSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_32f_P3R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_P3R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Resize32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Resize32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, oDstSize Size, nDstStep int32, oDstROI Rect, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiResize_32f_P4R(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiResize_32f_P4R_Ctx(&srccptrs[0], (C.int)(nSrcStep), oSrcSize.c(), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstSize.c(), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//NppiResizeBatchCXR is a binding for C.NppiResizeBatchCXR struct
/*
  typedef struct
  {
	  const void * pSrc;  // device memory pointer
	  int nSrcStep;
	  void * pDst;         //device memory pointer
	  int nDstStep;
  } NppiResizeBatchCXR;

*/
type NppiResizeBatchCXR C.NppiResizeBatchCXR

func (n *NppiResizeBatchCXR) cptr() *C.NppiResizeBatchCXR {
	return (*C.NppiResizeBatchCXR)(n)
}
func (n NppiResizeBatchCXR) c() C.NppiResizeBatchCXR {
	return (C.NppiResizeBatchCXR)(n)
}

//MakeNppiResizeBatchCXR binds a C.NppiResizeBatchCXR for use in go.
func MakeNppiResizeBatchCXR(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, ctx *StreamContext) NppiResizeBatchCXR {
	return (NppiResizeBatchCXR)(C.NppiResizeBatchCXR{
		pSrc:     pSrc,
		nSrcStep: (C.int)(nSrcStep),
		pDst:     pDst,
		nDstStep: (C.int)(nDstStep),
	})
}

//Set sets NppiResizeBatchCXR values
func (n *NppiResizeBatchCXR) Set(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, ctx *StreamContext) {
	n.pSrc = pSrc
	n.nSrcStep = (C.int)(nSrcStep)
	n.pDst = pDst
	n.nDstStep = (C.int)(nDstStep)
	return
}

//Get method returns value binded in C.NppiResizeBatchCXR
func (n *NppiResizeBatchCXR) Get() (pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32) {
	pSrc = n.pSrc
	nSrcStep = (int32)(n.nSrcStep)
	pDst = n.pDst
	nDstStep = (int32)(n.nDstStep)
	return pSrc, nSrcStep, pDst, nDstStep
}

//ResizeBatch8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC1R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C1R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_8u_C1R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()
}

//ResizeBatch8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC3R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C3R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_8u_C3R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC4R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C4R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_8u_C4R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uAC4R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_AC4R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_8u_AC4R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC1R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C1R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC3R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C3R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_32f_C3R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC4R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C4R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_32f_C4R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//ResizeBatch32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fAC4R(oSmallestSrcSize Size, oSrcROI Rect,
	oSmallestDstSize Size, oDstROI Rect, eInterpolation InterpolationMode,
	pBatchList []NppiResizeBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchList))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_AC4R(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiResizeBatch_32f_AC4R_Ctx(oSmallestSrcSize.c(), oSrcROI.c(), oSmallestDstSize.c(), oDstROI.c(), eInterpolation.cint(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//NppiImageDescriptor contains image information
type NppiImageDescriptor C.NppiImageDescriptor

//Set sets the NppiImageDescriptor Values
func (n *NppiImageDescriptor) Set(pData unsafe.Pointer, nStep int32, oSize Size) {
	n.pData = pData
	n.nStep = (C.int)(nStep)
	n.oSize = oSize.c()
}

//Get gets the NppiImageDescriptor Values
func (n *NppiImageDescriptor) Get() (pData unsafe.Pointer, nStep int32, oSize Size) {
	return n.pData, (int32)(n.nStep), (Size)(n.oSize)
}

//MakeNppiImageDescriptor makes an NppiImageDescriptor according to the values passed
func MakeNppiImageDescriptor(pData unsafe.Pointer, nStep int32, oSize Size) *NppiImageDescriptor {
	return &NppiImageDescriptor{
		pData: pData,
		nStep: (C.int)(nStep),
		oSize: oSize.c(),
	}
}
func (n NppiImageDescriptor) c() C.NppiImageDescriptor {
	return (C.NppiImageDescriptor)(n)
}
func (n *NppiImageDescriptor) cptr() *C.NppiImageDescriptor {
	return (*C.NppiImageDescriptor)(n)
}

/*
typedef struct
{
	void *    pData;  // device memory pointer to the image
	int 	  nStep;  // step size
	NppiSize  oSize;  // width and height of the image
} NppiImageDescriptor;
*/

//NppiResizeBatchROIAdvanced is a wrapper for C.NppiResizeBatchROI_Advanced
//and contains Src and Dst NppiRect
/*
typedef struct
{
	NppiRect oSrcRectROI;
	NppiRect oDstRectROI;
} NppiResizeBatchROI_Advanced;
*/
type NppiResizeBatchROIAdvanced C.NppiResizeBatchROI_Advanced

//Set sets the NppiResizeBatchROIAdvanced Values
func (n *NppiResizeBatchROIAdvanced) Set(oSrcRectROI, oDstRectROI Rect) {
	n.oSrcRectROI = oSrcRectROI.c()
	n.oDstRectROI = oDstRectROI.c()

}

//Get gets the NppiResizeBatchROIAdvanced Values
func (n *NppiResizeBatchROIAdvanced) Get() (oSrcRectROI, oDstRectROI Rect) {
	oSrcRectROI = (Rect)(n.oSrcRectROI)
	oDstRectROI = (Rect)(n.oDstRectROI)
	return oSrcRectROI, oDstRectROI
}

//MakeNppiResizeBatchROIAdvanced makes an NppiResizeBatchROIAdvanced according to the values passed
func MakeNppiResizeBatchROIAdvanced(oSrcRectROI, oDstRectROI Rect) *NppiResizeBatchROIAdvanced {
	return &NppiResizeBatchROIAdvanced{
		oSrcRectROI: oSrcRectROI.c(),
		oDstRectROI: oDstRectROI.c(),
	}
}
func (n NppiResizeBatchROIAdvanced) c() C.NppiResizeBatchROI_Advanced {
	return (C.NppiResizeBatchROI_Advanced)(n)
}
func (n *NppiResizeBatchROIAdvanced) cptr() *C.NppiResizeBatchROI_Advanced {
	return (*C.NppiResizeBatchROI_Advanced)(n)
}

//ResizeBatch8uC1RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC1RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C1R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_8u_C1R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch8uC3RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC3RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C3R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_8u_C3R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch8uC4RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uC4RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_C4R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_8u_C4R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch8uAC4RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch8uAC4RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_8u_AC4R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_8u_AC4R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch32fC1RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC1RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C1R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_32f_C1R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch32fC3RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC3RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C3R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_32f_C3R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch32fC4RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fC4RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_C4R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_32f_C4R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//ResizeBatch32fAC4RAdvanced are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func ResizeBatch32fAC4RAdvanced(nMaxWidth, nMaxHeight int32, pBatchSrc, pBatchDst []NppiImageDescriptor, pBatchROI []NppiResizeBatchROIAdvanced, eInterpolation InterpolationMode, ctx *StreamContext) error {
	nBatchSize := C.uint(len(pBatchSrc))
	if ctx == nil {
		return status(C.nppiResizeBatch_32f_AC4R_Advanced((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint())).ToError()
	}
	return status(C.nppiResizeBatch_32f_AC4R_Advanced_Ctx((C.int)(nMaxWidth), (C.int)(nMaxHeight), pBatchSrc[0].cptr(), pBatchDst[0].cptr(), pBatchROI[0].cptr(), nBatchSize, eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint8, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint8, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint8, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint8, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Uint8, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Uint8, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//Remap16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Uint16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Uint16, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Uint16, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sC1R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Int16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sC3R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Int16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Int16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sAC4R(pSrc *Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Int16, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_16s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sP3R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Int16, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 3)
	destcptrs := make([]*C.Npp16s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_16s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap16sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap16sP4R(pSrc []*Int16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Int16, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16s, 4)
	destcptrs := make([]*C.Npp16s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_16s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_16s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Float32, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Float32, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Float32, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32, pDst *Float32, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Float32, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 3)
	destcptrs := make([]*C.Npp32f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float32, nXMapStep int32, pYMap *Float32, nYMapStep int32,
	pDst []*Float32, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 4)
	destcptrs := make([]*C.Npp32f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fC1R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32, pDst *Float64, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_64f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fC3R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32, pDst *Float64, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_64f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32, pDst *Float64, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_64f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fAC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32, pDst *Float64, nDstStep int32, oDstSizeROI Size, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRemap_64f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), pDst.cptr(), (C.int)(nDstStep), oDstSizeROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fP3R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32,
	pDst []*Float64, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 3)
	destcptrs := make([]*C.Npp64f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_64f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()
}

//Remap64fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Remap64fP4R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pXMap *Float64, nXMapStep int32, pYMap *Float64, nYMapStep int32,
	pDst []*Float64, nDstStep int32, oDstROI Size,
	nXFactor, nYFactor, nXShift, nYShift float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 3)
	destcptrs := make([]*C.Npp64f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiRemap_64f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRemap_64f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pXMap.cptr(), (C.int)(nXMapStep), pYMap.cptr(), (C.int)(nYMapStep), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), eInterpolation.cint(), ctx.c())).ToError()

}

//GetRotateQuad are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetRotateQuad(oSrcROI Rect, nAngle, nShiftX, nShiftY float64) (q Quad, err error) {
	err = status(C.nppiGetRotateQuad(oSrcROI.c(), q.cptr2(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY))).ToError()
	return q, err
}

//GetRotateBound are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetRotateBound(oSrcROI Rect, nAngle, nShiftX, nShiftY float64) (aBounds Bound, err error) {
	err = status(C.nppiGetRotateBound(oSrcROI.c(), aBounds.cptr2(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY))).ToError()
	return aBounds, err

}

//Rotate8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Rotate32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Rotate32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, nAngle, nShiftX, nShiftY float64, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiRotate_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint())).ToError()
	}
	return status(C.nppiRotate_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), (C.double)(nAngle), (C.double)(nShiftX), (C.double)(nShiftY), eInterpolation.cint(), ctx.c())).ToError()

}

//Mirror8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC1R(pSrc *Uint8, nSrcStep int32, pDst *Uint8, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C1R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()
}

//Mirror8uC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC1IR(pSrc *Uint8, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C1IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C1IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC3R(pSrc *Uint8, nSrcStep int32, pDst *Uint8, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C3R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC3IR(pSrc *Uint8, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C3IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C3IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC4R(pSrc *Uint8, nSrcStep int32, pDst *Uint8, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uC4IR(pSrc *Uint8, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_C4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_C4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uAC4R(pSrc *Uint8, nSrcStep int32, pDst *Uint8, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_AC4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror8uAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror8uAC4IR(pSrc *Uint8, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_8u_AC4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_8u_AC4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC1R(pSrc *Uint16, nSrcStep int32, pDst *Uint16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C1R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC1IR(pSrc *Uint16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C1IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C1IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC3R(pSrc *Uint16, nSrcStep int32, pDst *Uint16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C3R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC3IR(pSrc *Uint16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C3IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C3IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC4R(pSrc *Uint16, nSrcStep int32, pDst *Uint16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uC4IR(pSrc *Uint16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_C4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_C4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uAC4R(pSrc *Uint16, nSrcStep int32, pDst *Uint16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_AC4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16uAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16uAC4IR(pSrc *Uint16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16u_AC4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16u_AC4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC1R(pSrc *Int16, nSrcStep int32, pDst *Int16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C1R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC1IR(pSrc *Int16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C1IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C1IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC3R(pSrc *Int16, nSrcStep int32, pDst *Int16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C3R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC3IR(pSrc *Int16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C3IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C3IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC4R(pSrc *Int16, nSrcStep int32, pDst *Int16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sC4IR(pSrc *Int16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_C4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_C4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sAC4R(pSrc *Int16, nSrcStep int32, pDst *Int16, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_AC4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror16sAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror16sAC4IR(pSrc *Int16, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_16s_AC4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_16s_AC4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC1R(pSrc *Int32, nSrcStep int32, pDst *Int32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C1R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC1IR(pSrc *Int32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C1IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C1IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC3R(pSrc *Int32, nSrcStep int32, pDst *Int32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C3R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC3IR(pSrc *Int32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C3IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C3IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC4R(pSrc *Int32, nSrcStep int32, pDst *Int32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sC4IR(pSrc *Int32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_C4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_C4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sAC4R(pSrc *Int32, nSrcStep int32, pDst *Int32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_AC4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32sAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32sAC4IR(pSrc *Int32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32s_AC4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32s_AC4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC1R(pSrc *Float32, nSrcStep int32, pDst *Float32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C1R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C1R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC1IR(pSrc *Float32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C1IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C1IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC3R(pSrc *Float32, nSrcStep int32, pDst *Float32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C3R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C3R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC3IR(pSrc *Float32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C3IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C3IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC4R(pSrc *Float32, nSrcStep int32, pDst *Float32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fC4IR(pSrc *Float32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_C4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_C4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fAC4R(pSrc *Float32, nSrcStep int32, pDst *Float32, nDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_AC4R(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_AC4R_Ctx(pSrc.cptr(), (C.int)(nSrcStep), pDst.cptr(), (C.int)(nDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//Mirror32fAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func Mirror32fAC4IR(pSrc *Float32, nSrcDstStep int32, oROI Size, flip Axis, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiMirror_32f_AC4IR(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c())).ToError()
	}
	return status(C.nppiMirror_32f_AC4IR_Ctx(pSrc.cptr(), (C.int)(nSrcDstStep), oROI.c(), flip.c(), ctx.c())).ToError()

}

//NppiMirrorBatchCXR is a  used with mirror batch funcs
type NppiMirrorBatchCXR C.NppiMirrorBatchCXR

//MakeNppiMirrorBatchCXR makes and returns an NppiMirrorBatchCXR
func MakeNppiMirrorBatchCXR(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, ctx *StreamContext) *NppiMirrorBatchCXR {
	return &NppiMirrorBatchCXR{
		pSrc:     pSrc,
		nSrcStep: (C.int)(nSrcStep),
		pDst:     pDst,
		nDstStep: (C.int)(nDstStep),
	}
}

//Get gets the values stored int the NppiMirrorBatchCXR struct
func (n *NppiMirrorBatchCXR) Get() (pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32) {
	return n.pSrc, (int32)(n.nSrcStep), n.pDst, (int32)(n.nDstStep)
}

//Set sets the values of an NppiMirrorBatchCXR
func (n *NppiMirrorBatchCXR) Set(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32) {
	n.pSrc = pSrc
	n.nSrcStep = (C.int)(nSrcStep)
	n.pDst = pDst
	n.nDstStep = (C.int)(nDstStep)
}
func (n *NppiMirrorBatchCXR) cptr() *C.NppiMirrorBatchCXR {
	return (*C.NppiMirrorBatchCXR)(n)
}
func (n NppiMirrorBatchCXR) c() C.NppiMirrorBatchCXR {
	return (C.NppiMirrorBatchCXR)(n)
}

/*
typedef struct
 {
	 const void * pSrc;  // device memory pointer, ignored for in place versions
	 int nSrcStep;
	 void * pDst;        // device memory pointer
	 int nDstStep;
 } NppiMirrorBatchCXR;
*/

//MirrorBatch32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC1R(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C1R(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C1R_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()
}

//MirrorBatch32fC1IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC1IR(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C1IR(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C1IR_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC3R(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C3R(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C3R_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fC3IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC3IR(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C3IR(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C3IR_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC4R(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C4R(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C4R_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fC4IR(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_C4IR(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_C4IR_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fAC4R(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_AC4R(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_AC4R_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//MirrorBatch32fAC4IR are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func MirrorBatch32fAC4IR(oSizeROI Size, flip Axis, pBatchList []NppiMirrorBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.int(len(pBatchList))
	if ctx == nil {
		return status(C.nppiMirrorBatch_32f_AC4IR(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiMirrorBatch_32f_AC4IR_Ctx(oSizeROI.c(), flip.c(), pBatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//GetAffineTransform are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetAffineTransform(oSrcROI Rect, aQuad Quad) (aCoeffs Coeffs, err error) {
	err = status(C.nppiGetAffineTransform(oSrcROI.c(), aQuad.cptr2(), aCoeffs.cptr2())).ToError()
	return aCoeffs, err
}

//GetAffineQuad are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetAffineQuad(oSrcROI Rect, aCoeffs Coeffs) (aQuad Quad, err error) {
	err = status(C.nppiGetAffineQuad(oSrcROI.c(), aQuad.cptr2(), aCoeffs.cptr2())).ToError()
	return aQuad, err
}

//GetAffineBound are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func GetAffineBound(oSrcROI Rect, aCoeffs Coeffs) (aBound Bound, err error) {
	err = status(C.nppiGetAffineBound(oSrcROI.c(), aBound.cptr2(), aCoeffs.cptr2())).ToError()
	return aBound, err
}

//WarpAffine8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()
}

//WarpAffine8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffine_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()
}

//WarpAffine8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffine_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffine_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 3)
	destcptrs := make([]*C.Npp32s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 4)
	destcptrs := make([]*C.Npp32s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 3)
	destcptrs := make([]*C.Npp32f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 4)
	destcptrs := make([]*C.Npp32f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fC1R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float64, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_64f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fC3R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float64, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_64f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float64, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_64f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fAC4R(pSrc *Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float64, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffine_64f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fP3R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float64, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 3)
	destcptrs := make([]*C.Npp64f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_64f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffine64fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffine64fP4R(pSrc []*Float64, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float64, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp64f, 4)
	destcptrs := make([]*C.Npp64f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffine_64f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffine_64f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

/*NppiWarpAffineBatchCXR struct is set up like this
typedef struct
{
	const void * pSrc;  // device memory pointer
	int nSrcStep;
	void * pDst;        // device memory pointer
	int nDstStep;
	Npp64f * pCoeffs;  //device memory pointer to the tranformation matrix with double precision floating-point coefficient values to be used for this image
	Npp64f aTransformedCoeffs[2][3]; // FOR INTERNAL USE, DO NOT INITIALIZE
} NppiWarpAffineBatchCXR;
*/
type NppiWarpAffineBatchCXR C.NppiWarpAffineBatchCXR

//Get gets the values stored int the NppiWarpAffineBatchCXR struct
func (n *NppiWarpAffineBatchCXR) Get() (pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, pCoeffs *Float64) {
	return n.pSrc, (int32)(n.nSrcStep), n.pDst, (int32)(n.nDstStep), (*Float64)(n.pCoeffs)
}

//Set sets the values of an NppiWarpAffineBatchCXR
func (n *NppiWarpAffineBatchCXR) Set(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, pCoeffs *Float64) {
	n.pSrc = pSrc
	n.nSrcStep = (C.int)(nSrcStep)
	n.pDst = pDst
	n.nDstStep = (C.int)(nDstStep)
	n.pCoeffs = pCoeffs.cptr()
}
func (n *NppiWarpAffineBatchCXR) cptr() *C.NppiWarpAffineBatchCXR {
	return (*C.NppiWarpAffineBatchCXR)(n)
}
func (n NppiWarpAffineBatchCXR) c() C.NppiWarpAffineBatchCXR {
	return (C.NppiWarpAffineBatchCXR)(n)
}

//WarpAffineBatchInit Initializes internal values
func WarpAffineBatchInit(BatchList []NppiWarpAffineBatchCXR) (err error) {
	nBatchSize := C.uint(len(BatchList))
	err = status(C.nppiWarpAffineBatchInit(BatchList[0].cptr(), nBatchSize)).ToError()
	return err
}

//WarpAffineBatch32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBatch32fC1R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpAffineBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpAffineBatch_32f_C1R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpAffineBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()
}

//WarpAffineBatch32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBatch32fC3R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpAffineBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpAffineBatch_32f_C3R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpAffineBatch_32f_C3R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpAffineBatch32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBatch32fC4R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpAffineBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpAffineBatch_32f_C4R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpAffineBatch_32f_C4R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpAffineBatch32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBatch32fAC4R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpAffineBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpAffineBatch_32f_AC4R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpAffineBatch_32f_AC4R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpAffineBack8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 3)
	destcptrs := make([]*C.Npp32s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 4)
	destcptrs := make([]*C.Npp32s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 3)
	destcptrs := make([]*C.Npp32f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineBack32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineBack32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect,
	aCoeffs Coeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 4)
	destcptrs := make([]*C.Npp32f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineBack_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineBack_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aCoeffs.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()
}

//WarpAffineQuad8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()
}

//WarpAffineQuad8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()
}

//WarpAffineQuad8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {

	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 3)
	destcptrs := make([]*C.Npp16u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, 4)
	destcptrs := make([]*C.Npp16u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 3)
	destcptrs := make([]*C.Npp32s, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, 4)
	destcptrs := make([]*C.Npp32s, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 3)
	destcptrs := make([]*C.Npp32f, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpAffineQuad32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpAffineQuad32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad,
	pDst []*Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, 4)
	destcptrs := make([]*C.Npp32f, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpAffineQuad_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpAffineQuad_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//GetPerspectiveTransform are functions found in the nppi library for cuda.
func GetPerspectiveTransform(oSrcROI Rect, quad Quad) (p PerspectiveCoeffs, err error) {
	err = status(C.nppiGetPerspectiveTransform(oSrcROI.c(), quad.cptr2(), p.cptr2())).ToError()
	return p, err
}

//GetPerspectiveQuad are functions found in the nppi library for cuda.
func GetPerspectiveQuad(oSrcROI Rect, p PerspectiveCoeffs) (quad Quad, err error) {
	err = status(C.nppiGetPerspectiveQuad(oSrcROI.c(), quad.cptr2(), p.cptr2())).ToError()
	return quad, err
}

//GetPerspectiveBound are functions found in the nppi library for cuda.
func GetPerspectiveBound(oSrcROI Rect, p PerspectiveCoeffs) (bound Bound, err error) {
	err = status(C.nppiGetPerspectiveBound(oSrcROI.c(), bound.cptr2(), p.cptr2())).ToError()
	return bound, err
}

//WarpPerspective8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 4)
	destcptrs := make([]*C.Npp8u, 4)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspective32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspective32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspective_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspective_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

/*NppiWarpPerspectiveBatchCXR - is a struct used for batched warps
typedef struct
{
	const void * pSrc;  //device memory pointer
	int nSrcStep;
	void * pDst;        //device memory pointer
	int nDstStep;
	Npp64f * pCoeffs;   // device memory pointer to the tranformation matrix with double precision floating-point coefficient values to be used for this image
	Npp64f aTransformedCoeffs[3][3]; // FOR INTERNAL USE, DO NOT INITIALIZE
} NppiWarpPerspectiveBatchCXR;
*/
type NppiWarpPerspectiveBatchCXR C.NppiWarpPerspectiveBatchCXR

//Get gets the values stored int the NppiWarpAffineBatchCXR struct
func (n *NppiWarpPerspectiveBatchCXR) Get() (pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, pCoeffs *Float64) {
	return n.pSrc, (int32)(n.nSrcStep), n.pDst, (int32)(n.nDstStep), (*Float64)(n.pCoeffs)
}

//Set sets the values of an NppiWarpAffineBatchCXR
func (n *NppiWarpPerspectiveBatchCXR) Set(pSrc unsafe.Pointer, nSrcStep int32, pDst unsafe.Pointer, nDstStep int32, pCoeffs *Float64) {
	n.pSrc = pSrc
	n.nSrcStep = (C.int)(nSrcStep)
	n.pDst = pDst
	n.nDstStep = (C.int)(nDstStep)
	n.pCoeffs = pCoeffs.cptr()
}
func (n *NppiWarpPerspectiveBatchCXR) cptr() *C.NppiWarpPerspectiveBatchCXR {
	return (*C.NppiWarpPerspectiveBatchCXR)(n)
}
func (n NppiWarpPerspectiveBatchCXR) c() C.NppiWarpPerspectiveBatchCXR {
	return (C.NppiWarpPerspectiveBatchCXR)(n)
}

//WarpPerspectiveBatchInit are functions found in the nppi library for cuda
func WarpPerspectiveBatchInit(BatchList []NppiWarpPerspectiveBatchCXR) (err error) {
	nBatchSize := C.uint(len(BatchList))
	err = status(C.nppiWarpPerspectiveBatchInit(BatchList[0].cptr(), nBatchSize)).ToError()
	return err

}

//WarpPerspectiveBatch32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBatch32fC1R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpPerspectiveBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBatch_32f_C1R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpPerspectiveBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpPerspectiveBatch32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBatch32fC3R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpPerspectiveBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBatch_32f_C1R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpPerspectiveBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpPerspectiveBatch32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBatch32fC4R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpPerspectiveBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBatch_32f_C1R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpPerspectiveBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpPerspectiveBatch32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBatch32fAC4R(oSmallestSrcSize Size, oSrcRectROI, oDstRectROI Rect, eInterpolation InterpolationMode, BatchList []NppiWarpPerspectiveBatchCXR, ctx *StreamContext) error {
	nBatchSize := C.uint(len(BatchList))
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBatch_32f_C1R(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize)).ToError()
	}
	return status(C.nppiWarpPerspectiveBatch_32f_C1R_Ctx(oSmallestSrcSize.c(), oSrcRectROI.c(), oDstRectROI.c(), eInterpolation.cint(), BatchList[0].cptr(), nBatchSize, ctx.c())).ToError()

}

//WarpPerspectiveBack8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, 3)
	destcptrs := make([]*C.Npp8u, 3)
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Int32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, pDst *Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveBack32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveBack32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect,
	pDst []*Float32, nDstStep int32, oDstROI Rect, p PerspectiveCoeffs, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveBack_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveBack_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), p.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uC1R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uC3R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uAC4R(pSrc *Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint8, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uP3R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, len(pSrc))
	destcptrs := make([]*C.Npp8u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad8uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad8uP4R(pSrc []*Uint8, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Uint8, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp8u, len(pSrc))
	destcptrs := make([]*C.Npp8u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_8u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_8u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uC1R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uC3R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uAC4R(pSrc *Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Uint16, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uP3R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad16uP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad16uP4R(pSrc []*Uint16, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Uint16, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp16u, len(pSrc))
	destcptrs := make([]*C.Npp16u, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_16u_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_16u_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sC1R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sC3R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sAC4R(pSrc *Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Int32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sP3R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Int32, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_P3R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_P3R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32sP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32sP4R(pSrc []*Int32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Int32, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32s, len(pSrc))
	destcptrs := make([]*C.Npp32s, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32s_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32s_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fC1R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fC1R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_C1R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_C1R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fC3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fC3R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_C3R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_C3R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_C4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_C4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fAC4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fAC4R(pSrc *Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, SrcQuad Quad, pDst *Float32, nDstStep int32, oDstROI Rect, DstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_AC4R(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_AC4R_Ctx(pSrc.cptr(), oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), SrcQuad.cptr2(), pDst.cptr(), (C.int)(nDstStep), oDstROI.c(), DstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fP3R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fP3R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Float32, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}

//WarpPerspectiveQuad32fP4R are functions found in the nppi library for cuda. If ctx is nil function will do regular operation. If not nill  it will do Ctx version
func WarpPerspectiveQuad32fP4R(pSrc []*Float32, oSrcSize Size, nSrcStep int32, oSrcROI Rect, aSrcQuad Quad,
	pDst []*Float32, nDstStep int32, oDstROI Rect, aDstQuad Quad, eInterpolation InterpolationMode, ctx *StreamContext) error {
	srccptrs := make([]*C.Npp32f, len(pSrc))
	destcptrs := make([]*C.Npp32f, len(pDst))
	for i := range pSrc {
		srccptrs[i] = pSrc[i].cptr()
		destcptrs[i] = pDst[i].cptr()
	}
	if ctx == nil {
		return status(C.nppiWarpPerspectiveQuad_32f_P4R(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint())).ToError()
	}
	return status(C.nppiWarpPerspectiveQuad_32f_P4R_Ctx(&srccptrs[0], oSrcSize.c(), (C.int)(nSrcStep), oSrcROI.c(), aSrcQuad.cptr2(), &destcptrs[0], (C.int)(nDstStep), oDstROI.c(), aDstQuad.cptr2(), eInterpolation.cint(), ctx.c())).ToError()

}
